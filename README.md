# Effective Go (RU) (Эффективное программирование на языке Go)

Оригинал смотри: https://golang.org/doc/effective_go.html
```
go version go1.7.4
```

## Введение


Go - это новый язык программирования. Хотя он заимствует идеи из существующих языков, он обладает необычными свойствами, которые делают эффективные программы Go отличающиеся по своему характеру от программ, написанных на его родственных. Прямолинейный перевод C++ или Java программ в Go вряд ли даст удовлетворительный результат, т.к. Java программы написаны на Java, не на Go. С другой стороны, думая о проблеме с точки зрения Go можно добиться успеха, но это уже другая программа. Другими словами, для написания на Go хорошо, важно понимать его особенности и идиомы.
Также важно знать установленные соглашения для программирования на Go, такие как именование, форматирование, разработка программ и так далее, так чтобы программы написанные Вами были простыми для понимания другими программистами Go.



Этот документ дает примеры для написания чистого, идеоматичного кода на Go.
Он дополняет [спецификацию языка](https://golang.org/ref/spec),
 [Тур по Go](https://tour.golang.org/),
и [Как написать на Go](https://golang.org/doc/code.html),
каждую из которых необходимо прочитать в первую очередь.


### Примеры


[Go пакеты исходных кодов](https://golang.org/src/) предназначены не только в качестве основных библиотек, но и в качестве примеров использования языка.
Кроме того, многие пакеты имеют работающие, автономные исполняемые примеры и Вы можете запустить напрямую с помощью [golang.org](https://golang.org) страницы, такие как [этот](https://golang.org/pkg/strings/#example_Map) ( если  необходимо, нажмите на слово "Примеры" чтобы открыть его).
Если у Вас есть вопрос о том как решить какую-либо проблему или как что-то реализовать, то документация, исходные коды и примеры в библиотеке могут дать ответ, идею или объяснение.



## Форматирование

Форматирование является наиболее спорным и менее важным.
Люди могут адаптироваться к различным стилям форматирования, но было бы лучше если бы этого не приходилось делать и меньше времени придавались этой теме, если бы все использовали одинаковый стиль.
Проблема данной утопии в том как это сделать без длинного руководства по стилю.


В Go мы используем нетипичный подход и передаем машине заботу о форматировании. ```gofmt``` программа (также доступна как ```go fmt```, который действует на уровне пакета а не на уровне файлов) читающая код на Go и выпускает исходный код в стандарном стиле отступов и вертикальном выравнивании, сохраняющая и если необходимо переформатирует комментарии.
Если Вы хотите знать - как справиться с новой ситуацией размещения кода, то запустите ```gofmt```; если ответ не будет правильным, то ```gofmt``` поправить Вашу программу (или файл сообщит об ошибки ```gofmt```), не работайте в обход форматирования программой ```gofmt```.


К примеру, нет необходимости тратить время на выравнивание комментариев в структуре кода. ```Gofmt``` сделает это за Вас. Принимая во внимание принятые соглашения.


```golang
type T struct {
    name string // name of the object
    value int // its value
}
```


_ ```gofmt``` будет выравнивать по колонкам:


```golang
type T struct {
    name    string // name of the object
    value   int    // its value
}
```


Все стандартные пакеты Go отформатированны с помощью ```gofmt```.




Некоторые детали форматирования. Очень кратко:


<dl>
    <dt>Абзац</dt>
    <dd>Мы используем табуляцию для абзацев и ```gofmt``` делает это по умолчанию. Используйте пробелы только если вы должны.
    </dd>
    <dt>Длина строки</dt>
    <dd>
    Go не имеет предела длинны строки. Не беспокойтесь о длинных строках. Если длина строки слишком длинная, то переведите на другуб строку и сделайте с дополнительной табуляцией.
    </dd>
    <dt>Круглые скобки</dt>
    <dd>
    Go нуждается в меньшем количестве круглых скобок чем C и Java: структуры ветвления, цикла ( ```if``` , ```for``` , ```switch```) не имеют круглых скобок в своем синтаксисе.
    Также, иерархия операторов стала проще и короче. К примеру,
```
x<<8 + y<<16
```
    добавлением пробелов, в отличии от других языков.
    </dd>
</dl>

## Комментарии


Go использует C-стиль ```/* */``` для блока комментариев
and C++-стиль ```//``` для комментариев однострочных.
Типично используется однострочные комментарии; Блок комментариев в основном используется для комментировании пакетов, но также для выразительности или отключения большого участка кода.



Программа -и веб-сервер-```godoc``` обрабатывает Go исходники для формирования документации о содержимом пакета.
Комментарии расположенные до верхней объявлением(диклорацией) без добавления пустых строк извлекаются вместе с диклорацией для пояснения данного элемента.
Характер и стиль комментариев напрямую влияет на качество документации производимой ```godoc```.



Каждый пакет должен иметь *комментарии пакета*, это блок комментариев предшествующий диклорации пакета.
Для пакетов состоящий из нескольких файлов, комментарии пакета должны быть расположены в одном файле или в любой из них.
Комментарии пакета должен представлять информацию о пакете целиком.
Он сначало появляется на странице ```godoc``` и должна представлять из себя детальную информацию, которой можно следовать.


```golang
/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
```


Если пакет простой, то комментарий пакет может быть кратким.


```golang
// Package path implements utility routines for
// manipulating slash-separated filename paths.
```


Не требуется дополнительное формативание, к примеру баннер из * (звездочек).
Шрифт для сформированного результата не обязательно будет миниширинный, поэтому не стои использовать выравнивание пробелами ```godoc```, также как ```gofmt```, заботиться об этом.
Комментарии это интерпретируется как простой текст, поэтому HTML и другие аннотации такие как ```_this_```поспроизводяться *дословно* и поэтому не должно использоваться.
Одна установка ```godoc``` действительно делает отображение текста как моноширинного, подходит для вставки короткого кода.
*Комментарий пакета* для [```fmt```](https://golang.org/pkg/fmt/) пакета использует это для лучшего эффекта.

В зависимости от контекста, ```godoc``` не может переформатировать комментарии, поэтому убедитесь что это выглялит хорошо:
используйте правильное правописание, знаки препинятия и структуру предложения, и так далее.

Любые комментарии внутри пакета установленые до диклорации служат как *doc comment* для диклорации.
Каждое экспортируемое(начанающаяся с большой первой буквой) должна иметь *doc comment*.

*Doc comments* работают хорошо как предложения, которые позволяют широкий спектр автоматических репрезентаций.
Первое предложения должно ключевым и начинаться с объявления имени.

```golang
// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
```

Если комментарий начинается с имени, то в результате ```godoc``` может с пользой запустить ```grep```.
Представте что Вы не можете вспомнить имя "Compile", но Вы ищите *the parsing function* для регулярных выражений и тогда вы можете запустить

```command
$ godoc regexp | grep parse
```

Если все *doc comments* в пакете начанаються с "This function...", ```grep``` не сможет помочь с вспоминанием имени. Только потому что *doc comment*  пакета начинается с имени, Вы можете увидеть что то вроде этого, которое напоминает слово которое вы ищите.

```command
$ godoc regexp | grep parse
    Compile parses a regular expression and returns, if successful, a Regexp
    parsed. It simplifies safe initialization of global variables holding
    cannot be parsed. It simplifies safe initialization of global variables
$
```

Диклорация синтаксиса Go допускает групповую диклорацию.
В один *doc comment* может представлять целую группу констант или переменных.
Однако такая целиковая диклорация выглядит небрежно.

```golang
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
```

Группировка также может показать взаимосвязи между элементами, которые к примеру по-факту группа переменных защищенных mutex.

```golang
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
```

## Именование

Именование очень важно в Go, как и в других языках.
И оно имеет семантический эффект: Видимость за пределами пакета означает что первая буква должна быть большой.
Именно поэтому стоит уделить время на обсуждение соглашения об именовании в Go программах.

### Именование пакетов

Когда пакет импортируется, имя пакета используется для доступа к содержимому.

```golang
import "bytes"
```

После того, как пакет импорта может говорить о ```bytes.Buffer```. Это полезно, если все с помощью пакета можно использовать то же имя для обозначения его содержимого, что означает, что имя пакета должно быть хорошим: коротким, кратким, запоминающим. В соответствии с соглашением, пакеты приведены в нижнем регистре, имена однословные; не должно быть оснований для подчеркивания или mixedCaps. Ошибка краткости, означает что каждый кто используя ваш пакет будет вводить это имя. И не беспокойтесь о столкновениях *априори*. Имя пакета - Это то что импортируется по-умолчанию; оно не должно быть уникальным во всем исходном коде, а в редких случаях столкновения имя импортируемого пакета можно заменить на другое имя для использования на местном уровне. В любом случае, путаница встречается редко, так как имя файла в импорте определяет, какой именно пакет используется.

Другом соглашение является то, что имя пакета является базовым именем его исходного каталога; пакет ```src/encoding/base64``` импортируется как ```"encoding/base64"```, но имеет название ```base64```, а не ```encoding_base64``` и не ```encodingBase64```.

Импортер пакета будет использовать имя для обозначения его содержимого, поэтому экспорт имен в пакет могут использовать этот факт, чтобы избежать повторения. (Не используйте ```import .```) Например, тип буферного чтения расположен в пакете ```bufio``` называется ```Reader```, а не ```BufReader```, т.к полхователи его видят как ```bufio.Reader```, и это кратко и ясно.

Кроме того, так как импортируемые объекты адрессуються с именем пакета, к примеру ```bufio.Reader``` не будет конфликта с ```io.Reader```.
Аналогично с функциями, для создания новую сущность(объекта) можно использовать имя ```ring.Ring```, которая объявлена как *конструктор* в Go; также допустимо вызов ```NewRing```, но так как ```Ring``` это характерна для определенного пакета и так как пакет называется ```ring```, то если использоать имя  просто как ```New```, то любой кто использует Ваш пакет будет видеть как ```ring.New```.
Используйте структуру пакета для того чтобы хорошо подобрать имена.

Другой короткий пример ```once.Do```; ```once.Do(setup)``` читается неплохо и не будет улучшена если имя будет ```once.DoOrWaitUntilDone(setup)```.
Длинные имена не делает более читабельным.
В то время как документация может больше ценным, чем длинные имена.

## Геттеры

Go не предоставляет автоматическую поддержку геттеров и сеттеров.
Но небудет ошибкой создание геттеров и сеттеров самому, и если это необходимо то делайте так, но идиоматически нет необходимости добавлять ```Get``` в имя геттера. Если у Вас есть поле с именем ```owner``` (с маленькой буквы, не экспортируемый), то геттер может называться ```Owner``` (с большой буквы, экспортируемый), а не ```GetOwner```.
Использовуйте имена с большой буквы для экспортирования для различия полей от методов(функций).
Для сеттеров, если необходимо, то лучше незывать```SetOwner```.
Оба примера в следующем коде:

```golang
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Имена интерфейсам

Согласно соглашению, интерфейсы с одним методомдолжен называться как метод с суффиксом -er или некоторые другое для образования существительного: ```Reader```, ```Writer```, ```Formatter```, ```CloseNotifier``` и так далее.

Есть целый ряд таких имен, и они соблюдать соглашение. ```Read``` , ``` Write``` , ```Close```,``` Flush```, ```String``` и так далее имеют канонические подписи и значения. Чтобы избежать путаницы, не давайте методу неодного из этих имен, если оно не имеет ту же подпись и значение.

С другой стороны, если ваш тип имеет метод с тем же значением как и метод на хорошо известный тип, то дайте ему то же имя и значение; назовите Ваш метод конвертации в строку как ```String``` , а не ```ToString```.


### MixedCaps

В заключении, Go соглашение использует ```MixedCaps``` или ```mixedCaps```, а не подчеркивание для имен из нескольких слов.


### Точка с запятой

Формально грамматика Go использует точку с запятой в конце операции(строки), как и в языке C, но не так как в языке C, так как точка с запятой не отображается в коде.
Вместо закона используйте простое правило для вставки точки с запятой автоматически при сканировании, т.е. в большенстве случаев вводимый текст не имеет их.

Правило в следующем.

Если последний маркер перед символом новой строки является идентификатором (который включает в себя такие слова, как ```int``` и ```float64```), основным буквальным, например, номер или строковой константы, или один из маркеров

```golang
break continue fallthrough return ++ -- ) }
```
закон - всегда добавляйте точку с запятой после маркеров.

Несколько примеров:

```golang
     go func() { for { dst <- <-src } }()
```

```golang
if i < f() {
    g()
}
```

но не так

```golang
if i < f()  // wrong!
{           // wrong!
    g()
}
```


## Управляющие структуры

Управляющие структуры Go похоже на С, но отличается.
Go не имеет ```do``` или ```while``` циклов, лишь обощенные ```for``` , ```switch``` которые более гибкие; ```if``` и ```switch``` допускают отсутствие инициализации как в ```for```; ```break``` и ```continue``` могут иметь ярлыки для индентификации чего именно прервать или продолжить и эти управляющие структуры включают переключитель типов - ```type switch``` и многоканальный коммуникатор ```select```.

Синтаксис также немного отличается: нет никаких круглых скобок и тело всегда должно иметь разделители - фигурные скобки ```{ }```.

### If

В Go простое использование ```if``` условие выглядит так:

```golang
if x > 0 {
    return y
}
```

Обязательные фигурные скобки поддерживают написание простых условиях ```if``` на несколько строк. Это хороший стиль в любом случае, особенно когда тело содержит управляющий оператор, такие как ```return``` или ```break```.

Однако ```if``` и  ```switch``` допускают наличие начальных условий для создания локальной переменной.

```golang
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

В библиотеке Go, вы увидете это когда условие ```if``` не переходит в следующее условие, тело заканчивается ```break```, ```continue```, ```goto```, или ```return``` — ненужное ```else``` опускается.


```golang
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

Это общей пример, когда код должен защититься от последовательности условий ошибок. Код читает хорошо, если успешный поток управления проходит вниз страницы, исключая случаи ошибок по мере их возникновения. Так как в случаи ошибок, как правило, заканчиваются ```return``` заявлений, результирующий код не нуждается в ```else``` объявлении.

```golang
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

### Переопределение и переназначение

Последниий пример предедущего раздела  - показывает короткую форму декларации переменных ```:=```. Вызов ```os.Open``` деклорирует сразу две переменных ```f``` и ```err```.

```golang
f, err := os.Open(name)
```

Несколько строк до этого, вызов чтения ```f.Stat``` было произведена декларация 2 переменных ```d``` и ```err```.

```golang
d, err := f.Stat()
```

Заметьте, что ```err``` появляется в обоих случаях.
Это дублирование разрешено: ```err``` в первом случаи декларируетяс в первую очередь, и переназначаеться во втором.
То есть вызов ```f.Stat``` использует уже существующую переменную ```err``` и просто добавляет новое значение.

В деклорации ```:=``` переменной ```v``` можно использовать, даже если она уже объявлена при условии:


**TODO: перевести**
* this declaration is in the same scope as the existing declaration of ```v```
(if ```v``` is already declared in an outer scope, the declaration will create a new variable §),
* the corresponding value in the initialization is assignable to ```v```, and
* there is at least one other variable in the declaration that is being declared anew.
**-**

Эта не типичное решение создана из чистого прагматизма - сделать использование простой переменной ```err```, к примеру при длинных условиях ```if-else```.
Вы заметете, что это используется часто.

**TODO: перевести**
§ It's worth noting here that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body.
**-**

### Оператор For

В Go цикл ```for``` похожий но не очень на используемый в C.
Он используется как ```for``` и  ```while``` и не используется как ```do-while```.
Имеет 3 различных формы и только в одной из них используется точка с запятой.

```golang
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
```

Простое объявление позволяет легко объявить начальные условия цикла.

```golang
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

Если Вы используете цикл по массиву, слайсу, строке или маппу(карте, map) или читаете из канала, то для управления можно использовать ```range```.

```golang
for key, value := range oldMap {
    newMap[key] = value
}
```

Если Вы будете использовать только по первому элементу в *range* (ключ или индекс), можете пропустить второй элемент:

```golang
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```


If you only need the second item in the range (the value), use the *blank identifier*, an underscore, to discard the first:

```golang
sum := 0
for _ , value := range array {
    sum += value
}
```

Использование в цикле по строке```range``` делает для Вас намного большее, к примеру разделяет строку по символам Unicode в соответствии с UTF-8.
При ошибочном использование кодировки по-байтово и заменяет рунами(*rune*) U+FFFD.
(```rune``` в терминологии Go используеться для работы с символами Unicode. Смотрите детальную информацию [Спецификацию языка](https://golang.org/ref/spec#Rune_literals)).

Данный цикл:

```golang
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```

Выводит:

```command
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

В языке Go не используються операторы запятая, ```++```, ```--```.
Если Вам необходимо использовать несколько переменных в цикле ```for```, то Вы можете использовать параллельное определение переменных (без использования ```++``` и ```--```).

```golang
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### Switch(переключатель)

В языке Go ```switch``` в основном такой же как в языке C.
Выражение не обязательно должно быть константой или целым числом. Условия проверяються сверху-вниз до того пока не найдет совпадение.
Если ```switch``` не имеет выражения, то переходит(переключаеться) до получения значения ```true```.
В связи с этим идиоматически можно записывать ```if``` - ```else``` - ```if``` - ```else``` как ```switch```.

```golang
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

Отсутствие автоматическое пропускане условий, поэтому условия могут представлены через запятую.

```golang
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Также допускается использовать ```break``` для прерывания работы ```switch``` *заранее*.
Иногда, необходимо прерывать цикл, не переключатель, и тогда можно использовать подписи(*label*) в цикле и "прерывать" по подписи.
Смотрите следующий пример:

```golang
Loop:
	for n := 0; n < len(src); n += size {
		switch {
		case src[n] < sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] < sizeTwo:
			if n+1 >= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]<<shift)
		}
	}
```

Естественно, ```continue``` также допускает подписи, но они используються только для циклов.
В заключении, сравните методы для байтовых слайсов использующий два ```switch```:

```golang
// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### Переключатель типов (Type switch)

Переключетель ```switch``` может использоваться для динамических типов переменных интерфейсов. Синтаксическое использование *type switch* типов производиться с помощью слова ```type``` внутри скобок.
Если в условии переключателе переменная, то эта тип переменной будет проверяться в теле.


**TODO**
It's also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.
**-**



```golang
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T prints whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
```

## Функции(Functions, методы)

### Множественное возвращение результатов

Одно из особенностей языка Go - это то что, функции, методы могут возвращать множество значений.

При использовании языка С, передача ошибки производиться через отрицательное значение с описание причины ошибки  другом месте.

При использовании языка Go, ```Write``` может вернуть одновременно **и** возвращаемое значение **и** ошибку.
Сингнатура метода ```Write``` в файлах пакета ```os```:

```golang
func (file *File) Write(b []byte) (n int, err error)
```

и как предусмотрено документацией, он возвращает число записанных байт и ненулевое значение ошибки ```error``` когда ```n``` ```!=``` ```len(b)```.
Это общий стиль, смотрите также раздел посвященный ошибкам в качестве примера.

Данный подход исключает необходимость в возращении значимого параметра.
Это очень простой способ возвращении из функции количества байт слайса, возвращая число и следующий параметр.

```golang
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

Вы можете сканировать число чисел во входном слайсе ```b``` следующим образом:


```golang
    for i := 0; i < len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
```

### Именование параметров результата

Возвращаемым "параметрам" в языке Go можно давать имена и это часто используется как входные параметры.
Когда они именованы, то они инициализируються нулевым значением необходимого типа в самом начале функции.
**TODO**
 if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values.
**-**


Именование не обязательное, но оно может сделать код короче и чище, самодокументируемым.
Ели имя результата будет ```nextInt```, то очевидно что тип результата ```int```.


```golang
func nextInt(b []byte, pos int) (value, nextPos int) {
```

На примере ```io.ReadFull```:


```golang
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```

### Отсроченный вызов (Defer)

В языке Go есть оператор ```defer``` для управления отложенного вызова функции, которые будут вызваны как только функция имеющая ```defer``` окончаться.
Это не типичный но эффективный способ, когда необходимо закрыть ресурс после окончания функции.
Канонические примеры - работа с mutex или закрытие файла.

```golang
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

Отложенный вызов функции ```Close``` имеет 2 преимущества. Во-певых, гарантирует что не будет забыто закрытие файла - ошибка которое легко сделать если в последствии будет в функции будет изменено не другой папку. Во-вторых,  закрытие близко расположено к открытию, что более ясно чем распологать в конце функции.

Аргументы отложенной функции выполняються когда выполняется ```defer```, а не когда функция вызвана.
Кроме того , во избежания беспокойства по поводу изменяющихся переменных в функции, одна отложенная функция может отложить вызов множества функций.

Вот простой пример:

```golang
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
```

Откладывание функции в LIFO очередь, приведет к следующей работе функции при печати на экран ```4 3 2 1 0``` . Более интересный пример - простое отслеживание функции в программе. Мы могли бы написать простое отслеживание как это:


```golang
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
```

Мы могли бы сделать лучше - используя факт отложенных функций для оценки когда будет запущен ```defer```. Отслеживаемая функция может настроить агрументы неотслеживаемой функции.
К примеру:

```golang
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
```


выводит:


```
entering: b
in b
entering: a
in a
leaving: a
leaving: b
```

Для программистов привыкших к блочному управлению ресерсами в других языках, функция ```defer``` может показаться странной, но интересной и мощной, так как позволяет перейти от блочного управления к управления в функции. В разделах ```panic``` и ```recover``` будут также рассматриваться несколько примеров.


## Данные

### Созданные с помощью ```new```

Для создания приметивов в языке Go используються функции ```new``` и ```make```.
Они разные и применяються для разных типов, это может сбить с толку, но правило очень просто.
Для начало обсудим функцию ```new```.
Данная функция резервирует память, но нетакже как в других языках программирования, он не *инициализирует* память, а вместо этого заполняет *нулями*.

К примеру ```new(T)``` резервирует память нулями для нового элемента типа ```T``` и возвращает его указатель, а значение типа ```*T```. В терминологии Go, он возвращает указатель на новый зарезирвируемую память заполненная нулями с типом ```T```.


**TODO**
Since the memory returned by ```new``` is zeroed, it's helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization.  This means a user of the data structure can create one with ```new``` and get right to work.
For example, the documentation for ```bytes.Buffer``` states that "the zero value for ```Buffer``` is an empty buffer ready to use."
Similarly, ```sync.Mutex``` does not have an explicit constructor or ```Init``` method.
Instead, the zero value for a ```sync.Mutex``` is defined to be an unlocked mutex.
The zero-value-is-useful property works transitively. Consider this type declaration.
**-**

```golang
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

**TODO**
Values of type ```SyncedBuffer``` are also ready to use immediately upon allocation or just declaration.  In the next snippet, both ```p``` and ```v``` will work correctly without further arrangement.
**-**

```golang
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```

### Конструкторы и сложные литералы

Иногда нулевое значение не достаточно и необходимо иметь конструктор, следующий пример взят из пакета ```os```.

```golang
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```

Существует много шаблонов. Мы просто можем использовать *сложные литералы*, которые будут создавать новые сущности каждый раз.

```golang
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

Обратите внимание что в отличии от С, это нормально возвращать адресс локальных переменных, так как переменная существует после возвращения из функции.
На самом деле, возвращение адрессов сложных литералов создает новую сущность каждый раз, как он вычисляется.
итак мы можем объединить последние две строки:

```golang
    return &File{fd, name, nil, 0}
```

Поля сложных литералов должны быть в порядке объявления и должны все присутствовать.
Однако, используя маркировку как *поле*```:```*значение* пара, может инициализируеться в любом порядке, с пропущенными полями заполняемые нулями.
Таким образом, можно объявить:

```golang
    return &File{fd: fd, name: name}
```

В предельном случаи, когда сложный литерал без полей вообще, то создание нулевым значением будет тип. Выражения ```new(File)``` и ```&File{}``` одинаковы.


Сложные литералы могут также создавать массивы, слайсы, карты, с пометкой полей как индексов или ключами карт.
К примеру, инициализированные значения ```Enone```, ```Eio```, и ```Einval``` разные.


```golang
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```

### Создание с помощью ```make```

Возвращаясь к созданию элементов.
Встроенная функция ```make(T, ```*args*```)``` служит для других целей нежели ```new(T)```.
Он создает только слайсы, карты и каналы, и возвращают *инициализированные* (не нулями) значение типа ```T``` (а не ```*T```).
Причиной различия для этих трех типов в том что внутри они представляют из себя структуры данных, которые необходимо инициализировать перед использованием.
К примеру, слайсы - это трехэлементная структура, содержающий указатель на данные(внутри массив), длину, и емкость, причем пока все элементы не инициализированы - слайс *Нулевой* ```nil```.
Для слайсов, карт и каналов, встроенная команда ```make``` инииализирует внутреннюю структуру данных и подготавливает значения к использованию.

К примеру:

```golang
make([]int, 10, 100)
```

создает массив из 100 значений типа ```int``` и затем создает структуру слайс длинной 10 и емкотью 100 со ссылкой только на первые 10 элементов.
(Когда создается слайс, его емкость задавать не обязательно, смотрите раздел посвященный слайсом.)
В противоположность, ```new([]int)``` возвращает указатель на новый, созданный, запоненный нулями слайс, это указатель на ```nil``` значение слайса.


Эти примеры показывают различие между ```new``` и ```make```.


```golang
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
```

Помните что ```make``` используеться только для карт, слайсов и каналов и не возвращают указатель.
Для получения указателя в явном виде используйте ```new``` или  возьмите указатель в явном виде.

### Массивы

Массивы популярны когда точно известно необходимое количество памяти и не делать излишних пересозданий, но в первую очередь они являються составной частью для слайсов, о которых будет описано в следующем разделе.

Какие основные отличия между обращением с массивами между языками Go и C.


There are major differences between the ways arrays work in Go and C.
In Go,

* Массивы значений. Присвоение одно массива другому копирует все элементы.
* Если вы передаете массив в функцию, то передается копия массива, а не указатель на него.
* Размер массива является частью массива. Типы ```[10]int``` и ```[20]int``` разные.

Массивы могут быть полезными, но дорогими(с точки зрения производительности) и если Вы хотите поведение и эффективность схожее с поведением в языке C-like, то необходимо использвать в функциях указатели.


```golang
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
```

Но данный стиль не подходит Go.
Используйте слайсы вместо массивов.


### Слайсы(Slices, срез)

Слайсы это обертка для массивов и при это этом более общий, мощный и предоставляет более удобный интерфейс по управлению данными. В случаях когда не известно точное количество элементов и необходимо преобразование массивов.
Большенство массивов в языке Go выполнены с использование слайсов, а не простых массивов.

Слайс хранит ссылку на массив и поэтому если приравнять слайс к другому слайсу, то будет тот же массив.
Если слайс является аргументом функция, то изменения элементов в слайсе будут видны вызывающему данному функцию, это аналогично передачи указателя на базовый массив.
В функции ```Read``` может принимать в качестве аргумента слайс, что равнозначно указателя на массиву и длине массива; длина слайса указывает верхний предел количество данных которые необходимо прочитать.
В данном случаи для типа ```File``` пакета ```os``` имеет следующую сигнатуру метода ```Read```:

```golang
func (f * File) Read(buf []byte) (n int, err error)
```

Метод возвращает количество прочитанных байт или если есть то ошибку.
Для чтения первых 32 байт в буфере ```buf```, *получить(срезать) часть* буфера.

```golang
    n, err := f.Read(buf[0:32])
```

Такой срез является эффективным. На самом деле, если оставить в стороне эффективность, то следующий пример показывает чтение первых 32 байт из буфера.

```golang
    var n int
    var err error
    for i := 0; i < 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
```

Длина слайса(среза) может меняться меняться, пока не исчерпает размер внутреннего массива.
С помощью встроенной функции ```cap``` можно узнать *емкость* слайса, представляющая макимальной длиной среза.
В следующем примере расматривается функция для добавления данных в слайс.
Если данные превышают емкость слайса, то слайс необходимо переопределить.
Функция ```Append``` возвращает результирующий слайс. Функция использует тот факт что  использование ```len``` и ```cap``` допустимо даже если у нас имееться ```nil``` слайс - возращая 0.

```golang
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))* 2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
```


**TODO**
We must return the slice afterwards because, although ```Append```
can modify the elements of ```slice```, the slice itself (the run-time data
structure holding the pointer, length, and capacity) is passed by value.
**-**

Добавление элементов в слайс настолько популярна, что функция ```append``` тала встроенной. Для того чтобы понять принцип работы данной функции нам необходимо больше информации, поэтому мы вернемся к этому позже.


### Двухмерные слайсы(срезы)

Массивы и срезы в Go - одномерные.
Для создания эквивалентого двухмерного массива или среза, то нам необходимо определять массив-массивов или срез-срезов, как в примере:

```golang
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
```

В связи с тем что срезы переменной длины, то допустимо иметь каждый внутренний срез разной длины.
Это наиболее общая ситуация, как в ```LinesOfText``` примере, в котором каждая строка имеет независимую длину.

```golang
text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
```

Иногда необходимо создавать двухмерные срезы, к примеру при обработки пикселей.
Есть 2 способа для этого.
Первый, создание каждого среза независимо и второй создание простого массива срезов.
Наилучшый способ выбирается в зависимости от программы.
Если срез можно увеличивать или уменьшать, они должны быть независимы для того чтобы избежать перезаписи новых строк. Если не требуется изменять размер, то наиболее эффективным был бы способ с создание одним их созданием.
Рассмотрим оба способа.

```golang
// Allocate the top-level slice.
picture := make([][]uint8, YSize) // One row per unit of y.
// Loop over the rows, allocating the slice for each row.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
```

с одним созданием:

```golang
// Allocate the top-level slice, the same as before.
picture := make([][]uint8, YSize) // One row per unit of y.
// Allocate one large slice to hold all the pixels.
pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
// Loop over the rows, slicing each row from the front of the remaining pixels slice.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

### Карты(Maps)

Карты - это удобный и мощный встроенная структура данных, связывабщий значение одного типа(*ключ (key)*) со значением другого типа (*элемент (element)* или *значение (value)*).
Ключ может быть любого типа для которого определен оператор равно, как для целых чисел, чисел с плавающей точкой или комплексные числа, строки, указатели, интерфейсы (если динамические типы поддерживают равенство), структуры и массивы.
Срезы не используются в качестве ключа для карт, так как равенство не определено для них.
Карты, также как и срезы, имеют внутреннюю структуру данных.
Ели Вы передадите карту в функции и измените содержание карты, то изменения остануться для вызывающего.
Карты могут быть созданы с использованием синтаксиса сложных литералов с разделением по колонкам пар ключ-значение, поэтому легко создать начальные данные.

```golang
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

Добавление и получение значений из карт синтаксически выглядит как для массивов или срезов, за тем исключение того что индекс не оюязательно должен быть целым числом.

```golang
offset := timeZone["EST"]
```

При попытки получения значения из карты по ключю, которого нет в карте, приведет к возвращению нулевого значения.
К примеру, если карта содержит целые числа, то описывалось выше, для несуществующего ключа будет возвращено ```0```.
Это можно представить как карту у которой в качестве типа значения используется ```bool```. Добавление записи в карту это как добавление со значением ```true``` в карту и дальнейшая простая проверка на индексирование.

```golang
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
```

Иногда необходимо отличать отсутствие записи от нулевего значения. К примеру, есть ли запись для ```"UTC"``` или это пустая строка потому что отсутсвует значение в карте?
Для того чтобы отличить - Вы можете использовать множественное присвоение.

```golang
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```

Очевидная причина называть данную идиому "запятая ок".
В данном примере, если ```tz``` существует, то ```seconds``` будет иметь необходимое значение и ```ok``` будет ```true```, но если не существует, то ```seconds``` будет иметь нулевое значение а ```ok``` будет ```false```.
В следующем примере, представлена функция с хорошей описанием ошибки:

```golang
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
```

В случаи если нам не беспокоит само значение, а лишь его наличие, то можно использовать **пустой идентификатор ```_```** расположенный вместо значения.

```golang
_ , present := timeZone[tz]
```

Для удаления записи из карты, необходимо использовать встроенную функцию ```delete```, где в качестве аргументов задается карта и ключ для удаления.
Данная операция безопасна, даже если данного ключа уже нет в карте.

```golang
delete(timeZone, "PDT")  // Now on Standard Time
```

### Печать(Printing)

Форматированная печать в Go использует стилю в языке C ```printf```, но более богаче и более обобщенное. Необходимые функции расположены в пакете ```fmt``` и имеют назавания с большой буквы: ```fmt.Printf```, ```fmt.Fprintf```, ```fmt.Sprintf``` и так далее.  Функции (```Sprintf``` и другие) возвращают строку, а не заполняют предоставленный буфер.

Вам нет необходимости в создании форматировании строк, так как для каждой  ```Printf```, ```Fprintf``` and ```Sprintf``` есть пара функций к примеру ```Print``` и ```Println```.

Данные функции не берут формат строки, а вместо этого устанавливают форматирование по-умолчанию для каждого аргумента. Функция ```Println``` также добавляет пробел между аргументами и добавляет разрыв строки в конце строки. Функция```Print``` добавляет пробел только если той же строке.
В примере каждая строка производит одинаковый результат.

```golang
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

Для форматированной печати функцией ```fmt.Fprint``` и его друзьями, принимают в качестве первого аргумента объект реализующий интерфейс ```io.Writer```.
Значения ```os.Stdout``` и ```os.Stderr``` знакомы.


Следующее расходится с реализацией на языке С. Первое, числовые форматы ```%d``` не имеют флагов знаковости или размера; Вместо этого, функции печати используют тип аргумента для задания свойств.

```golang
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
```

печатает

```
18446744073709551615 ffffffffffffffff; -1 -1
```

Если вы использовать соглашение по-умолчание, то для целых чисел можно использовать обобщенный формат ```%v``` (для "значений"); и результат будет одинаков как для  ```Print``` так и для ```Println```.

Более того, данный формат может напечатать *любое* значение, даже срез, структуру или карту.
Печать карты временной зоны из предедущего раздела.

```golang
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
```

который печатает следующий результат

```
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
```

Ключи карт могут быть напечатаны в любом порядке.
При печати структуры, с аннотацией ```%+v``` производиться печать полей структуры с их именами и для каждого значение с форматом ```%#v``` печатается значение с полным интаксисом Go.

```golang
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

печатает

```
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
```

(На заметку: обратите внимание на амперсанты)

Для ссылок на строки подходит ```%q```, который принимает значение на ```string``` или ```[]byte```.
Альтернативный формат ```%#q``` будет использовать обратные кавычки, если это возможно.
(Формат ```%q``` также допустим для целых чисел и рун, создавая односсылочные константы рун.)
Также, ```%x``` работает со строками, массивом байт и срезом байт также как с целыми числами, создает шеснадцатиричные целые строки, а с пробелом в формате (```% x```) добавляет пробелы между байтами.


Другой удобный формат ```%T```, который печатает *тип* значения.

```golang
fmt.Printf("%T\n", timeZone)
```

печатает

```
map[string] int
```

Если Вы хотите свой собственный формат типа, то для этого достаточно метод с сигнатурой ```String() string``` для Вашего типа.
Для нашего простого примера, тип ```T```, выглядит следующим образом.

```golang
func (t * T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

Печатает в следующем формате

```
7/-2.35/"abc\tdef"
```

(Если Ваш необходимо напечатать *значение* типа ```T``` как указателя на тип ```T```, то метод ```String``` должен иметь значение типа; этот пример использует указатель, т.к. они более эффективны и идиоматичны типу структуры.)


Наша функция ```String``` может вызывать ```Sprintf```, потому что функция печати возвращаемая и поэтому можно её обернуть. Это важно для понимания данного подхода.
Однако, не создавайте функцию ```String``` вызывающую метод ```Sprintf```, в случаи если далее будет рекурсирно вызвана ```String```.
Это может произойти если ```Sprintf``` вызывает на печать строку получателя, который вызовет функцию снова. Это ошибку можно легко создать и она показана на следующем примере.

```golang
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
```

Для того чтобы решить, необходимо изменить аргумент на базовый тип, который не имеет функции.

```golang
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
```

Другой способ печати это допустить печать функции аргументов напрямую в другую функцию.
Сигнатура ```Printf``` используется для типов ```...interface{}```, что допускает произвольное число аргументов, которые добавляються после формата *format*.

```golang
func Printf(format string, v ...interface{}) (n int, err error) {
```

**TODO**
Within the function ```Printf```, ```v``` acts like a variable of type ```[]interface{}``` but if it is passed to another variadic function, it acts like a regular list of arguments.
Here is the implementation of the function ```log.Println``` we used above. It passes  its arguments directly to ```fmt.Sprintln``` for the actual formatting.
**-**

```golang
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
```

Запись ```...``` после ```v``` при вызове функции ```Sprintln``` объявляет компилятору о том что ```v``` является списком аргументов; сдругой стороны ```v``` воспринимается как простой срез аргументов.

Если Вас необходимо большее количество информации, то смотрите документацию ```godoc``` в пакете```fmt```.

Кстати параметр ```...``` может иметь тип, для примера```...int``` для функции определения минимума используется список целых чисел:

```golang
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _ , i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```

### Присоединение(Append)

В настоящий момент пришел момент для разъяснения конструкции встроенной функции```append```. Сигнатура функции ```append``` отличается от ранее описанной функции ```Append```.
Схематично, выглядит следующим образом:

```golang
func append(slice []*T*, elements ...*T*) []*T*
```

где *T* любой тип. Вы не можете написать в языке Go функцию в которой ```T``` определена вызывающим. Поэтому необходима поддержка компилятора для функции ```append```.

Данная функция ```append``` добавляет элемент в конец среза и возвращает результат.
Причина возврата результата в том что как в рукописной функции ```Append``` массив может измениться.
Простой пример:

```golang
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

печатает ```[1 2 3 4 5 6]```.  Итак, ```append``` работает в принципе как ```Printf``` с произвольным количеством аргументов.


Но что если необходимо добавить срез в срез, как в нашей реализации ```Append```? Все просто: используем ```...``` который мы использовали в ```Output```. Вот пример кода для получение того же результата.

```golang
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
```

Обращаю внимание, что без ```...``` компилятор напишит ошибку, так как ```y``` не имеет тип ```int```.


## Инициализация(Initialization)

Инициализация в языке Go более мощный инструмент нежели в языках С или С++.
Даже сложные структуры можно инициализировать. Упорядочивание между инициализируемыми объектами разных пакетов, обрабатывается корректно.


### Константы(Constants)


Константы в Go это просто константы.
Они создаються во время компиляции даже если она определена в локальной функции и могут быть цифры, символы(руны), строки или булевый тип.
Из-за ограничения времени компиляции, компилатор должен определять какие выражения могут быть константами. К примеру, выражение ```1<<3```  это константное выражение, в то время как выражение ```math.Sin(math.Pi/4)``` не является константой, так как вызывает функцию ```math.Sin``` требующую выполнения по время выполнения.


В языке Go, перечисление констант производиться с помощью перечислятора **```iota```**. Так как ```iota``` может быть неявно повторяемой для выражения или выражений, то легко можно строить сложные наборы значений.


```golang
//{{code "/doc/progs/eff_bytesize.go" `/^type ByteSize/` `/^\)/`}}
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "fmt"

type ByteSize float64

const (
	_           = iota // ignore first value by assigning to blank identifier
	KB ByteSize = 1 << (10 * iota)
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)
```

Использование функции ```String``` к пользовательским типам производить печать необходимым образом.
**TODO**
Although you'll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like ```ByteSize```.
**-**

```golang
//{{code "/doc/progs/eff_bytesize.go" `/^func.*ByteSize.*String/` `/^}/`}}

func (b ByteSize) String() string {
	switch {
	case b >= YB:
		return fmt.Sprintf("%.2fYB", b/YB)
	case b >= ZB:
		return fmt.Sprintf("%.2fZB", b/ZB)
	case b >= EB:
		return fmt.Sprintf("%.2fEB", b/EB)
	case b >= PB:
		return fmt.Sprintf("%.2fPB", b/PB)
	case b >= TB:
		return fmt.Sprintf("%.2fTB", b/TB)
	case b >= GB:
		return fmt.Sprintf("%.2fGB", b/GB)
	case b >= MB:
		return fmt.Sprintf("%.2fMB", b/MB)
	case b >= KB:
		return fmt.Sprintf("%.2fKB", b/KB)
	}
	return fmt.Sprintf("%.2fB", b)
}
```

Выражение ```YB``` печатается как ```1.00YB```, когда ```ByteSize(1e13)``` печатает как ```9.09TB```.


Используемый здесь ```Sprintf``` в функции ```String``` типа ```ByteSize``` безопасна(не вызывается рекурсивно), не потому что происходит конвертирование, а потому что вызывается функция ```Sprintf``` с ```%f```, который не строковый формат: ```Sprintf``` будет вызывать функцию ```String```, функцию которой необходима строка и ```%f``` число с плавающей точкой.


### Переменные(Variables)

Переменные могут инициализироваться как константы, но инициализация производиться во время работы.

```golang
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
```

### Функция init

Каждый исходный код определить свою первичную функцию ```init``` для обязательных  настройки. (На самом деле файл можт иметь несколько функций ```init```.)
И наконец значит в конце: функция ```init``` вызывается после всех объявлений переменных и после всех объявлений переменных всех пакетов.

Общее применение функции ```init``` в проверки или починки состояния программы до начала реального исполнения.

```golang
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&gopath, "gopath", gopath, "override default GOPATH")
}
```

## Методы(Methods)

### Указатели или Значения

Как мы видели в примеры с ```ByteSize```, функции может иметь имя типа (кроме указателей или интерфейсов) и приемник не обязательно должен иметь структуры.

Как обсуждалось ранее в срезах, мы написали функцию ```Append```.
Мы можем определить функции вместе со срезом. Для этого, мы объявим именованный тип, который мы можем связать с функцией и там самым создать получателя данной функции для значений этого типа.

```golang
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as the Append function defined above.
}
```

Данный метод все также возвращает обновленный срез. Для решения этой неуклюжести можно воспользоаться *указателем* на ```ByteSize``` в получатель, итак сожет быть переписана следующим образом.

```golang
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
```

На самом деле, мы можем сделать это ещё лучше. Если мы изменим функцию, то она будет выглядить как стандартная функция ```Write```, то есть вот так,

```golang
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
```

тип ```*ByteSlice``` удовлетворяет стандартному интерфейсу ```io.Writer```, что удобно. Например, мы можем напечатать один из них:

```golang
    var b ByteSlice
    fmt.Fprintf(&b, "This hour has %d days\n", 7)
```

Мы передаем адресс ```ByteSlice```, поскольку только ```*ByteSlice``` удовлетворяет интерфейсу ```io.Writer```.
Правило получателя *о указателях или значениях* в том что функции значения могут использоваться для указателей и значений, а функция указателямогут только использовать указатель.


Это правило возникло потому что функции указателя могут изменять получателя.
Вызывая значение в функции значений получаешь копию значения, поэтому никаких модификаций не произойдет.
Поэтому язык запрещает эту ошибку.
Когда адрессуется значение, то язык заботиться что подставляя символ адресации автоматически.

К примеру, переменная ```b``` адрессованная, поэтому мы можем вызвать функцию ```Write``` просто вызвав ```b.Write```.
Компилятор сам допишет ```(&b).Write``` за нас.


Кстати, идея использования ```Write``` на срезах байт наиважнейшая для реализации ```bytes.Buffer```.


## Интерфейсы и другие типы

### Интерфейсы

Интерфейсы в Go позволяют создать особое поведения для объектов: *Если нечто может делать* **это** *, то это можно использовать* **здесь**. Мы уже это встречали в простых примерах, когда реализовывали функцию ```String``` для печати, в то время как ```Fprintf``` может выдавать на печать другое с методом ```Write```.
Интерфейсы с одним или двумя функциями свойственны в языке Go, как ```io.Writer``` реализующий ```Write```.

Любой тип может реализовывать множество интерфейсов.
К примеру, коллекции могут быть отсортированы с помощью функций из пакета ```sort```, если она реализует ```sort.Interface```, который состоит из ```Len()```, ```Less(i, j int) bool```, и ```Swap(i, j int)``` и это может задать собственный формат.
Рассмотрим пример ```Sequence```

```golang
//{{code "/doc/progs/eff_sequence.go" `/^type/` "$"}}
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"sort"
)

func main() {
	seq := Sequence{6, 2, -1, 44, 16}
	sort.Sort(seq)
	fmt.Println(seq)
}

type Sequence []int

// Methods required by sort.Interface.
func (s Sequence) Len() int {
	return len(s)
}
func (s Sequence) Less(i, j int) bool {
	return s[i] < s[j]
}
func (s Sequence) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

// Method for printing - sorts the elements before printing.
func (s Sequence) String() string {
	sort.Sort(s)
	str := "["
	for i, elem := range s {
		if i > 0 {
			str += " "
		}
		str += fmt.Sprint(elem)
	}
	return str + "]"
}
```

### Преобразование (Conversions)

Функция ```String``` работает с ```Sequence``` и ```Sprint``` уже работает со срезами. Мы может распространить данный эффект, ели конвертируем  ```Sequence``` на  ```[]int``` до вызова ```Sprint```.

```golang
func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
```

Это функция другой пример технику конвертирования для вызова ```Sprintf``` безопасно для функции ```String```.
Так как два типа (```Sequence``` и ```[]int```) одинаковы, то мы можем игнорировать имя типа, это допустимое конвертирование между ними.
При конвертации не происходит создание нового значения, это временная замена существующего значения на новый тип.
(При других допустимых конвертациях, к примеру из целого числа в число с плавающей точкой, происходи создание нового значения.)


Это идиоматично в программе Go - конвертация типа производиться получения доступа к другим функциям. К примеру, мы можем использовать существующий тип ```sort.IntSlice```:

```golang
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
```

Теперь, наш ```Sequence``` реализует множество интерфейсов (сортировка и печать),  мы можем использовать множество типов (```Sequence```, ```sort.IntSlice```
and ```[]int```), которые выполняют определенную часть работ.
Это не типично в использовании но эффективно.

### Конвертация интерфейсов и привязка типов

Переключатель типов(Type switches) является одной из форм конвертации: которая на основе интерфейса и переключателя для каждого элемента, в некотором смысле преобразует тип в элемент переключателя.
Это простой вариант как в коде ```fmt.Printf``` конвертирует значение в строку, используя переключатель типа.
И если это уже строка, мы хотим чтобы фактическое значение происходило по его интерфейсу, но в случаи если она имеет функцию ```String```, то хотим чтобы в результате вызывалась именно она.

```golang
type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
```

В первом случат ищется конкретное значение, во втором случаи происходит преобразование интерфейса в другой интерфейс.
Это хороший подход в перемещивании типов.

Что если, мы будет беспокоиться лишь об одном типе? Если мы знаем что значение имеет тип ```string``` и мы хотим вытащить только его?
Можно сделать переключатель только с одним типом, но это будет *type assertion*.
И *type assertion* берет значение интерфейса и переводит из его значения в его тип.
Заимствование типа из открытия *type switch*, но переводит тип с помощью ключевого слова ```type```:

```golang
value.(typeName)
```

и в результате у нас значение со статическим типом ```typeName```.
Этот тип должен быть конкретным типом имеющим интерфейс, или второй тип интерфейса - это тип в который может быть сконвертирован.
Если мы знаем что это строка в значении, то мы можем записать:


```golang
str := value.(string)
```

Но если выясниться, что значение хранит не строку, то программа будет обружена во время работы *a run-time error*.
для защиты от этого используется идиома *запятая, ок* *"comma, ok"* для безопасности и проверка является ли значение строкой:


```golang
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```

В случаи неудачи, ```str``` будет всё ещё существовать и будет типом строка, но будет иметь нулевое значени - путую строку.


Для иллюстрации, используем условие ```if```-```else``` как эквивалент переключателя типов *type switch* в начале этого раздела.

```golang
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
```

### Общее(Generality)

Если тип существует только для реализации интерфейса и никогда не будет экспортироваться за пределы интерфейса, то нет необходимости экспортировать сам тип.
Экспортирование только интерфейса делает более понятным значение имеет не интересное поведение за пределами описанного интерфейса.
Также это позволяет избегать повторения документации для каждого экземпляра общего метода.


Втаких случаях, конструктор может возвращать значение интерфейса, что лучше чем реализованный тип.
Для примера, в  библиотеках хэш *hash* оба конструктора ```crc32.NewIEEE``` и ```adler32.New``` возвращают тип интерфейса ```hash.Hash32```.
Для подстановки алгоритма CRC-32 для Adler-32 в программе Go требуется только изменить вызов конструктора, а остальная часть кода не зависит от алгоритма.


Подобный подход позволяет создать поток шифровальных алгоритмов в различных пакетов ```crypto``` устанавливаются в цепь отделенные от блока шифрования.
Интерфейс ```Block``` в пакете ```crypto/cipher``` имеющий поведение шифрование, который обеспечивает шифрование одного блока данных.
Это по аналогии с пакетом ```bufio```, пакет шифрования реализует этот интерфейс может использовать конструктор поток шифрования, представление интерфейса ```Stream``` без известных деталей о шифрования.

Интерфейсы ```crypto/cipher``` выглядят следующим образом:

```golang
type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
```

Определение режима счетчика потока *counter mode (CTR) stream*, который превращает блоки шифрования в поток шифрования, обратите внимание, что шифрование блоков абстрагировано:

```golang
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
```

Принятое ```NewCTR``` не только для одного конкретного алгоритма шифрования и исходных данных, но для любой реализации интерфейса ```Block``` и любой ```Stream```.
Так как он возвращает тип интерфейса, замена шифрование CTR с другими режимами шифрования это локальное изменение. Вызов конструктора должен быть отредактирован, а потому что окружающий код не заметит разницы , так как результат ```Stream```.


### Интерфейсы и методы(функции)

Так как метод может иметь почти всё, поэтому все можно удовлетворить интерфейсами.
Один из примеров из пакета ```http```, который имеет интерфейс ```Handler```. Любой объект реализующий ```Handler``` может служить для HTTP запросов.

```golang
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

Сам интерфейс ```ResponseWriter``` обеспечивает функции для возврата запроса клиенту.
Эти функции включают метод ```Write```, то ```http.ResponseWriter``` можно  использовать везде как где можно использовать ```io.Writer```. ```Request``` это структура хранящая информацию о запросе от клиента.

Для упрощения, давайте игнорировать POSTs и предположим что HTTP запросы всегда используют GETs; Это упрощение не влияет на способ натройки обработчика *handlers*.
К примеру следующий код показывает полный обработчик для подсчета количества раз показа данной страницы.

```golang
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
```

(Обратите внимание, на то как ```Fprintf``` печатает в ```http.ResponseWriter```.)
Для справки, следующий код показывает как присоединить сервер к узлу в *URL tree*.

```golang
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
```

Но зачем использовать структуру для ```Counter```? Все что нам необходимо - это целое число.
(Для получателя *receiver* необходим указатель, тогда инкремент будет виден для вызывающего *caller*)

```golang
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
```

Что делать если Ваша программа имеет некое внутреннее состояние и необходимо уведомить что страница была посещена? Необходимо связать веб страницы каналом.

```golang
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
```

Если нам требуется представить на ```/args``` аргументы использованные для запуска приложения сервера.
Просто необходимо написать функцию для печати аргументов.

```golang
func ArgServer() {
    fmt.Println(os.Args)
}
```

Как превратить это в HTTP сервер?  Мы могли бы сделать метод ```ArgServer``` некоторого типа значение которого мы игнорируем, но сесть более простой путь.
Так как мы можем определить метод для любого типа, кроме указателя и интерфейса, то мы можем записать метод для функции.
В пакете ```http``` есть следующий код:

```golang
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
```

Это тип ```HandlerFunc``` с методом ```ServeHTTP```, поэтому значения данного типа может служит для запросов HTTP. Посмотрим на реализацию метода: *receiver* это функция, ```f```, и метод называется ```f```. Это может показаться странным, но это ничем не отличается от работы с каналами и метод бы отсылал на канал.

Для создания ```ArgServer``` как HTTP сервера, вначале мы изменим корректную сигнатуру.

```golang
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
```

Сейчас, ```ArgServer``` имеет ту же сигнатуру как ```HandlerFunc```, поэтому его можно конвертировать в этот тип для доступа к его методам, просто как сконвертировать ```Sequence``` в ```IntSlice``` для доступа к ```IntSlice.Sort```.
Код для настройки лаконичен:

```golang
http.Handle("/args", http.HandlerFunc(ArgServer))
```

Когда кто-то посещает страницу ```/args```, обработчик **handler** устанавливает страницу со значением ```ArgServer``` и типом ```HandlerFunc```.
Сервер HTTP будет вызывать метод ```ServeHTTP``` данного типа с получателем ```ArgServer```, который будет вызывать ```ArgServer``` через вызов ```f(c, req)```
внутри ```HandlerFunc.ServeHTTP```.
Вследствии этого аргументы будут отображены.

В этом разделе мы сделали сервер HTTP из структуры, целого числа, канала, и функции, все потому что интерфейсы имеют только набор методов, которые могут быть определены для (почти) любого типа.

## Пустой идентификатор (The blank identifier **_**)

Мы уже упоминали пустой идентификатор  пару раз, в разделах о циклах ```for``` ```range``` и картах ```maps```.
Пустой идентификаторможет быть назначен или объявлен для любого типа, значение при этом отбрасывается.
Это чем то похоже на запись в Unix файла в ```/dev/null```: Это значение только на запись, где переменна необходима, но значение не важно.
Есть дополнительные способы использования.

### Пустой дентификатор в множественном присваении (**_**)

Использование пустого идентификатора в цикле ```for``` ```range``` является лишь одним случаем применения в общей картине множественного присваения.


Если требуется множество значений на левой стороне при присваении, но одно из значений не будет использоваться программой, то используется пустой идентификатор на левой стороне присвоения для того чтобы избежать необходимости в ненужных переменных и создание чистого понимания об отброшенном значении.
Например, когда вызываетс функция возвращающая значение и ошибку, но при этом только ошибка важно, то пустой идентификатор используется для того чтобы отбросить ненужное значение.

```golang
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
```

Иногда Вы увидите код в котором отбрасывается ошибка, это ужасная практика. Всегда проверяйте возвращенную ошибку, так как они предоставляються по некой причине.


```golang
// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

### Неиспользуемое импортирование и значения

Ошибкой является неиспользование пакета или декларация переменной без использования.
Неиспользованный импорт увеличивает программу и делает компиляцию медленее, в то время как переменная инициализированная но не используемая, по крайней мере приводит к пустому вычислению или является индикатором об ошибке.
Однако неиспользуемые импорты и переменные возникают, когда программа на стадии активной разработки и удаление их может раздражать, только лишь для того чтобы прошла компиляция и если они снова понадобяться позже.
Пустые идентификаторы позволяют создать обход(**workaround**).

Это полунаписанная программа имеет два неиспользуемых импорта (```fmt``` и ```io```) и не используемую переменную (```fd```), и она не проходит компиляцию, но было бы хорошо если бы можно было увидеть что код корректен.

```golang
///{{code "/doc/progs/eff_unused1.go" `/package/` `$`}}
package main

import (
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	fd, err := os.Open("test.go")
	if err != nil {
		log.Fatal(err)
	}
	// TODO: use fd.
}
```

Для того чтобы избежать жалоб о неиспользуемых импортах, необходимо использовать символ пустого идентификатора для обозначения импортирования пакета.
Аналогично, можно поступать с неиспользуемой переменной ```fd``` при использовании пустого идентификатора, что приведет к избеганию ошибки о неиспользованной переменной.
Следующая весия программы будет компилироваться.

```golang
//{{code "/doc/progs/eff_unused2.go" `/package/` `$`}}
package main

import (
	"fmt"
	"io"
	"log"
	"os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
	fd, err := os.Open("test.go")
	if err != nil {
		log.Fatal(err)
	}
	// TODO: use fd.
	_ = fd
}
```

В соответствии с соглашением, глобальная декларация для замалчивания ошибки импорта должно идти сразу за импортированием и должно быть откомментировано, это сделано для того чтобы легко можно было найти и помнить об отчистки позже.

### Импортирование для побочного эффекта (Import for side effect)

Неиспользуемые импорты, как например ```fmt``` и ```io``` в предедущем примере, в конечном счете должны быть удалены: пустое задание должно определять что код в процессе разработки.
Но иногда, используется импортирование пакета только для создания побочного влияния, без какого либо явного использования.
К примеру, для функции ```init``` в пакете [net/http/pprof](https://golang.org/pkg/net/http/pprof/) регистрирует HTTP обработчики для обеспечения отладочной информацией.
Он имеет экспортированный API, но большенству клиентов необходима только регистрация обработчиков и получение доступа к данным через веб-страницу.
Только для импортирования пакета с этим побочным эффектом, переименовывают пакет в пустой идентификатор:

```golang
import _ "net/http/pprof"
```

Эта форма импортирования означает что данный пакет импортируется для данного побочного эффекта, потому что нет другой возможности использовать пакет: в этот файл, не имеет имени. (Если же он имеет и мы не используем это имя, то компилятор отменит программу.)


### Проверка интерфейса (Interface checks)

Как мы видели ранее в разделе об интерфейсах, нет необходимости в объявлении что тип реализует определенный интерфейс.
Вместо этого, тип реализует интерфейс только путем реализации методов интерфейса.
На практике, большенство преобразований интерфейсов статично и поэтому проверяется во время компиляции.


К примеру, передавая ```*os.File``` в функцию ожидающая ```io.Reader``` не будет скомпилировано, так как ```*os.File``` не реализует интерфейс ```io.Reader```.


Хотя все же некоторые проверки интерфейсов происходят во время выполнения.
Один из примеров в пакете [encoding/json](https://golang.org/pkg/encoding/json/), который определяет интерфейс [Marshaler](https://golang.org/pkg/encoding/json/#Marshaler). Когда **JSON encoder** принимает значение, которое реализует этот интерфейс, *encoder* вызывает функцию упаковщик значений для преобразования в JSON, в отличии от стандартного преобразования.

*Encoder* проверяет эти свойства во время работы:

```golang
m, ok := val.(json.Marshaler)
```

Если необходимо только запросить тип реализуемого интерфейса без использования самого интерфейса, то это часть проверки ошибок, используйте пустой идентификатор для игнорирования защиты типов:

```golang
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
```

Одна из ситуаций применения это когда необходимо гарантировать в рамках пакета что данный тип реализует интерфейс.
Если взглянуть на пример [json.RawMessage](https://golang.org/pkg/encoding/json/#RawMessage), где необходима пользовательское представление в формате JSON, он должен реализовывать ```json.Marshaler```, но отсутствует статическое преобразование для автоматической проверки компилятором.
Если определенный тип не будет реализовывать интерфейс, то *JSON encoder* будет все же работать, но без пользовательской реализации.
Для гарантирования корректной реализации, в пакете можете использовать пустой идентификатор для глобальной декларации:

```golang
var _ json.Marshaler = (*RawMessage)(nil)
```

в этой деклорации, присвоение с конвертацией ```*RawMessage``` к ```Marshaler``` требует чтобы, ```*RawMessage``` реализовывал ```Marshaler``` и данная проверка будет производиться во время компиляции.
В случаи если интерфейс ```json.Marshaler```, этот пакет не будет компилироваться и мы будем знать об обновлении.

Использование пустого идентификатора в данном случат является индикатором о проверки типов, и при этом не создается переменной.
Не используйте этот подход для проверки каждого типа.
В соответствии с соглашением, такая деклорация используется только когда отсутствует статическая конвертация уже существующая в коде, который является редким событием.



## Вложение (Embedding)

Язык Go не поддерживает типичное управление типов подклассов, но он имеет возможноть "заимствовать" части реализации с помощью типа *вложения* структуры или интерфейса.

Вложение интерфейса необячайно простое.
Мы уже упомянали об интерфейсах ```io.Reader``` and ```io.Writer``` ранее, вот их определение.

```golang
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Пакет ```io```также экспортирует несколько других интерфейсов, которые определяют объекты, которые могут реализовывать несколько таих методов.
К примеру, ```io.ReadWriter``` содержит оба интерфейса ```Read``` и ```Write```.
Мы может указать ```io.ReadWriter``` перечислением двух методов в явном виде, но это проще и более запомяющим будет встраивание двух интерфейсов в одну новую форму, вот так:

```golang
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
```

Это выглядит следующим образом: ```ReadWriter``` может делать все что делает ```Reader``` **и** что делает ```Writer```. Это объединение встраивания интерфейсов (которые не имеют пересечений в методах).
Только интерфейсы могут встраивать интерфейсы.

Аналогичная идея используется для структур, но с большим количеством последствий. Пакет ```bufio``` имеет две структуры типов - ```bufio.Reader``` и ```bufio.Writer```, каждая из которых реализует аналогичные интерфейсы как в пакете ```io```. И ```bufio``` также реализует буфферизованное чтение/запись, которое объединяет чтение и запись в одну структуру с использованием вложения: этот список типов структур, но не давая имена полям.

```golang
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
```

Вложение указателей элементов в структуры и конечно должно быть инициализированно необходимой структурой до его использования.
Стрктура ```ReadWriter``` может быть записана так:

```golang
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
```

**TODO**
but then to promote the methods of the fields and to
satisfy the ```io``` interfaces, we would also need
to provide forwarding methods, like this:
**-**


```golang
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
```

Для непосредственного вложения структур, мы должны избегать эту бухалтерию.
Метод вложенного типа приходит свободно, что означает что ```bufio.ReadWriter```имеет не только его методы ```bufio.Reader``` и ```bufio.Writer```, а также удовлетворяет всем трем интерфейсам:
* ```io.Reader```,
* ```io.Writer```, и
* ```io.ReadWriter```.


Это важное отличие вложения от подклассов. Когда мы вкладываем тип, методы этого типа становяться методами внешнего типа, но для получателя они вызываються как встроенные типы, а не внешние.
В нашем примере, когда метод ```Read``` из ```bufio.ReadWriter``` вызывается, он и вызываються также как описано выше; получатель поля ```reader``` из ```ReadWriter```, является самим ```ReadWriter```.

Вложение может быть простым и удобным.
Этот пример показывает вложение поля рядом с именованным полем.

```golang
type Job struct {
    Command string
    *log.Logger
}
```

Тип ```Job``` сейчас имеет ```Log```, ```Logf``` и другие методы ```*log.Logger```.
Мы могли бы дать имя для ```Logger```, конечно же, но в этом нет необходимости. И сейчас, мыможем логировать ```Job```:

```golang
job.Log("starting now...")
```

Регулярное поле ```Logger``` в структуре ```Job```, поэтому мы можем инициализировать его как обычно внутри конструктора ```Job```, вот так:

```golang
func NewJob(command string, logger *log.Logger) *Job {
    return &Job{command, logger}
}
```

или с помощью сложных литералов:

```golang
job := &Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
```

Если нам необходимо обратиться непосредственно к вложенному полю, имени типа поля, игнорируя пакетный классификатор, как к имени поля, как это сделано в методе ```Read``` в нашей структуре ```ReaderWriter```.
При этом нам необходим доступ к ```*log.Logger``` в ```Job``` переменной ```job```, мы можем написать ```job.Logger```, что полезно если мы хотим уточнить методы ```Logger```.

```golang
func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
```

Вложение типов создает проблему конфликта имен, но правила для их решения просты.



Первое, поли или метод ```X``` скрывает любой иной элемент ```X``` в более глубокой части вложенного типа.
Если ```log.Logger``` содержит поле или метод под названием ```Command```, то поле ```Command``` в ```Job``` будет преобладать над ним.


Во-вторых, если есть одинаковые имена на том же уровне вложенности, это как правило ошибка и было бы ошибочно вставлять ```log.Logger```, если структура ```Job``` имеет другое вложенное поле или метод с названием ```Logger```.
Однако, если дублированные имена никогда не встречаються в программе вне определенного типа, то это нормально.
Это защищает от изменения типов вложенности за его пределами; и это не проблема, если добавлено поле вступающее в конфликт с другим полем в другом подтипе, если ни одно из полей не используется.

## Согласованность, параллельная обработка, параллельное выполнение  (Concurrency)

### Распределение памяти по сообщениям (Share by communicating)

Параллельное программирование является большой темой и здесь будет рассматриваться только специфичное для языка Go.


Параллельное программирование во многих средах затруднено для корректной реализации доступа к общим переменным.

В языке Go поддерживается другой подход, в котором общие переменные *shared values* передаються через каналы, по сути, никогда активно не распределяет исполнение потоков.
Только одна го-рутина(**goroutine**) имеет доступ к переменной в любой момент.
Перенос данных не присходит по конструкции языка.
Для того чтобы способствовать данному стилю мышления используеться лозунг:


> Do not communicate by sharing memory; instead, share memory by communicating.

> Не общайтесь с распределением памяти; Вместо того чтобы распределять память коммуникациям.


Это дальновидный подход. К примеру, наилучшим образом подсчет ссылок можно произодить установкой мютексов(**mutex**) вокруг целого переменной.
Но это высокоуровневый подход, использование каналов для контроля доступа являеться более простым и корректным для программ.


Один из способов думать об этой модели как для типичных однопоточных программ запущенных на одном процессоре CPU. И нет необходимости в синхронизации примитивов.
Для запуска следующего экземпляра, нет необходимостив синхронизации. Сейчас рассмотрим два способа коммуникации; Если коммуникация синхронна, то все также не требуется в дополнительной синхронизациию. К примеру, *Unix pipelines* великолепно используют эту модель. Хотя подход языка Go для организации параллельных процессов берет начало в **Hoare's Communicating Sequential Processes (CSP)**, он также может рассматриваться как обобщения безопасности типов Unix pipes.


### Го-рутины (Goroutines)


Они называется Го-рутины, потомы что существующие термины потоки, корутины, процессы и так далее передают неточную коннотацию.
**Го-рутины** имеют простую модель: это функция выполняющаяся параллельно с другими го-рутинами а одном адресном пространстве. Они легковесны стоящие чуть больше чем выделение простанства в стэке. Они дешевы, и растут по мере необходимости путем выделения или освобождения в куче.



Горутины рапределяються на несколько покотов OS, и если один заблокируется, например из за ожидания I/O, другие продолжат работу. Их дизайн скрывает много сложностей по создание потоков и их управлению.


Префикс ```go``` у функции или метода запускает новую горутину.
Когда вызов закончен, горутина выходит, молча. (Этот эффект похож на команду Unix с нотацией ```&``` означающая запуск команды в фоновом режиме.)

```golang
go list.Sort()  // run list.Sort concurrently; don't wait for it.
```

Встроенные функции могут быть удобны для вызова горутин.

```golang
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
```

В языке Go, встоенные функции закрываемые и их реализация гарантирует что ссылаемые переменные будут жить до тех пор пока функция активна.

Эти примеры не очень практичны, так как функции не имеют сигнализировать о своем завершении. Для этого у нас есть каналы.


### Каналы (Channels)

Каналы, как и карты(map) выделяються в памяти с помощью ```make``` и полученное значение является ссылкой на изначальную структуру данных.
Если задан необязательный целый параметр, то он указывает на размер буффера в канале.
По умолчанию, значение нулевое, как для небуфферезованного или синхронного канала.

```golang
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
```

Небуфферезованные каналы гарантируют, что обмен значениями будет синхронным между двумя горутинами в известном сотоянии.


Есть много хороших идиом использования каналов. Вот один с которого мы начнем.
В предедущем разделе мы запускали сортировку в фоне. Канал может помощь отследить завершение горутины с сортировкой.

```golang
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c <- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
<-c   // Wait for sort to finish; discard sent value.
```

Получатель всегда блокируется до тех пор пока данные не получит получатель.
Если канал не буфферизованный, отсылающий блокируется до тех пор пока получатель не получит данные.
Если канал буфферизованный, то отсылающий блокируется только тогда когда значение копируется в буффер; если буффер полон, то будет ожидать до тех пор коку получатель не получит значение.

**TODO**
A buffered channel can be used like a semaphore, for instance to
limit throughput.  In this example, incoming requests are passed
to ```handle```, which sends a value into the channel, processes
the request, and then receives a value from the channel
to ready the "semaphore" for the next consumer.
The capacity of the channel buffer limits the number of
simultaneous calls to ```process```.
**-**

```golang
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    <-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
```

**TODO**
Once ```MaxOutstanding``` handlers are executing ```process```,
any more will block trying to send into the filled channel buffer,
until one of the existing handlers finishes and receives from the buffer.
**-**


Данный дизайн имеет проблемы: ```Serve```  создает новую горутину для каждого входящего запроса, при этом будет запущено не более ```MaxOutstanding``` в один момент.
Если количество запросов увеличивается слишком быстро, то как результат, программа может потребовать безконечное количество ресурсов.
Мы можем решить это изменением ```Serve``` используя изменения количества порождаемых горутин.
Вот очевидное решение, но будьте осторожны, так как оно имеет ошибку, которую позже исправим:

```golang
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func() {
            process(req) // Buggy; see explanation below.
            <-sem
        }()
    }
}
```

Ошибка в том, что в языке Go цикл ```for```, цикл переменной повторно используется для каждой итерации, так что переменные ```req``` разделяется по всем горутинам.
Это не то что мы хотим.
Нам нужно убедиться, что ```req``` является уникальной для каждой горутиной.
Вот один из способов, передавать значение ```req``` как в качестве аргумент для закрытии горутины:

```golang
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func(req *Request) {
            process(req)
            <-sem
        }(req)
    }
}
```

Сравнивая эту версию с предедущей можно увидеть раздницу в том как объявляется запуск и закрытие.
Другое решение заключается в том что создается новая переменная с тем же именем, как в примере:

```golang
func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem <- 1
        go func() {
            process(req)
            <-sem
        }()
    }
}
```

Может кажется странным, писать:


```golang
req := req
```


Но это допустимо и идиоматично делать это.
Вы получаете новую переменную с тем же именем, намеренно затеняя переменную цикла локально, но уникальный для каждой горутины.


Возвращаясь к общей проблеме написания сервера, иной подход для управления ресурсами начинается с фиксиции числа обработчиков ```handle``` горутин читающих из канала запросов.
Ограничение количества горутин количеством одновременных вызовов к ```process```.


Функция ```Serve``` также принимает канал, на который посылается об окончании; после запуска горутины блокируют получающих в этот канал.


```golang
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Start handlers
    for i := 0; i < MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    <-quit  // Wait to be told to exit.
}
```

### Канал каналов (Channels of channels)

Одно из важных свойств Go в том что каналы это переменная, а значит аллоцированы и могут передаваться как любой другой элемент. Одно из использований данной свойства в реализации безопасного и **параллельного демультиплексирования**.

В примере из предедущего раздела, ```handle``` был идеальным обработчиком для запросов, но он не определял тип обработки. Если тип включен в канал, на который отвечать, то каждый клиент может предоставить собственный путь для ответа. Вот схематичное определение типа ```Request```.

```golang
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
```

Клиент предоставляет функцию и ее аргументы, а также канал внутри объекта запроса, не который будет получен ответ.

```golang
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests <- request
// Wait for response.
fmt.Printf("answer: %d\n", <-request.resultChan)
```

На стороне сервера, функция обработчик это единственное что меняется.

```golang
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```

Этот пример является примером основой для ограничения скорости, параллелизма, неблокирующей RPC систесы и без использования мютекса.


### Параллелелизм (Parallelization)

Другой пример использования этих идей в расчете на наскольких ядрах CPU. Если расчет можно разбить на кусочки выполняющиеся независимо, то это можно разпараллелить с каналами сигнализирующие, когда отдельный кусочек закончил свою работу.

К примеру, у нас есть дорогая операция выполнения на векторе элементов и эти операции можно выполнять независимо, то вот идеализированный пример.

```golang
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1    // signal that this piece is done
}
```

Вы выполняем кусочки независимо в цикле, по одному CPU на кусочек.
Они могут закончить в любом порядке, но это не важно; мы только считаем количество сигналов окончания по каналу после запуска всех дорутин.

```golang
const numCPU = 4 // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // Buffering optional but sensible.
    for i := 0; i < numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i < numCPU; i++ {
        <-c    // wait for one task to complete
    }
    // All done.
}
```

Вместо того, чтобы создать постоянное значение для numCPU, мы можем задать во время выполнения необходимое значение.
Функция [runtime.NumCPU](https://golang.org/pkg/runtime/#NumCPU) возвращает количество ядер CPU в машине, тогда мы должны записать:

```golang
var numCPU = runtime.NumCPU()
```

Есть также такая функция [runtime.GOMAXPROCS](https://golang.org/pkg/runtime/#GOMAXPROCS), которая возаращаем заданное пользователем количество ядер, которая программа Go может использовать.
По умолчанию значение ```runtime.NumCPU```, но может быть переопределен путем установки в среде с тем де именем или вызовом функции с положительным числом.
Вызов с нулевым значением запрашивает значение.
Поэтому если мы хотим выполнить запрос ресурсов пользователя, мы должны написать

```golang
var numCPU = runtime.GOMAXPROCS(0)
```

Будьте уверены, чтобы не путать идеи параллельно-структурированной(**concurrency—structuring**) программы как независимо иполняемых компонентов и паралелльно-выполняемые вычисления(**parallelism—executing**) для эффективности на нескольких процессорах.
Хотя особеннсти *concurrency* в языке Go могут решить некоторые проблемы легко с использованием структур параллельного вычисления, Go является *concurrent* языком, не параллельным и не все проблемы параллелизма подходят модели Go.
Для обсуждения различий, смотрите [следующий блог](https://blog.golang.org/concurrency-is-not-parallelism).


### Утечка буффера (A leaky buffer)

Инструменты конкарентси программирования позволяет для неконкаренси идеям быть нагляднее. Вот пример из пакета RPC.  Цикл клиента горутины принимает данные из нескольких источников, возможно из сети. Для того чтобы избежать выделения и освобождения буферов, он пустой список и использует буферизованный канал для его представления. Если канал пуст, то выделяется новый буфер. После того, как буфер готов, он высылает на сервер на ```serverChan```.

```golang
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = <-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan <- b      // Send to server.
    }
}
```


Цикл сервера принимает каждое сообщение из клиента, обрабатывает его и возврает  буфер на пустое список.


```golang
func server() {
    for {
        b := <-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList <- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
```

Клиент пытаеться получить буфер из ```freeList```; если ни один не доступен, он выделяется новые.


The server's send to ```freeList``` puts ```b``` back
on the free list unless the list is full, in which case the
buffer is dropped on the floor to be reclaimed by
the garbage collector.



(The ```default``` clauses in the ```select```
statements execute when no other case is ready,
meaning that the ```selects``` never block.)
This implementation builds a leaky bucket free list
in just a few lines, relying on the buffered channel and
the garbage collector for bookkeeping.


## "errors">Errors


Library routines must often return some sort of error indication to
the caller.
As mentioned earlier, Go's multivalue return makes it
easy to return a detailed error description alongside the normal
return value.
It is good style to use this feature to provide detailed error information.
For example, as we'll see, ```os.Open``` doesn't
just return a ```nil``` pointer on failure, it also returns an
error value that describes what went wrong.



By convention, errors have type ```error```,
a simple built-in interface.

```golang
type error interface {
    Error() string
}
```

A library writer is free to implement this interface with a
richer model under the covers, making it possible not only
to see the error but also to provide some context.
As mentioned, alongside the usual ```*os.File```
return value, ```os.Open``` also returns an
error value.
If the file is opened successfully, the error will be ```nil```,
but when there is a problem, it will hold an ```os.PathError```:

```golang
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e * PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

_ ```PathError```'s ```Error``` generates
a string like this:

```command
open /etc/passwx: no such file or directory
```

Such an error, which includes the problematic file name, the
operation, and the operating system error it triggered, is useful even
if printed far from the call that caused it;
it is much more informative than the plain
"no such file or directory".



When feasible, error strings should identify their origin, such as by having
a prefix naming the operation or package that generated the error.  For example, in package ```image```, the string representation for a decoding error due to an
unknown format is "image: unknown format".



Callers that care about the precise error details can
use a type switch or a type assertion to look for specific
errors and extract details.  For ```PathErrors```
this might include examining the internal ```Err```
field for recoverable failures.


```golang
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```


The second ```if``` statement here is another <a href="#interface_conversions">type assertion</a>.
If it fails, ```ok``` will be false, and ```e```
will be ```nil```.
If it succeeds,  ```ok``` will be true, which means the
error was of type ```*os.PathError```, and then so is ```e```,
which we can examine for more information about the error.


### "panic">Panic


The usual way to report an error to a caller is to return an ```error``` as an extra return value.  The canonical ```Read``` method is a well-known instance; it returns a byte
count and an ```error```.  But what if the error is
unrecoverable?  Sometimes the program simply cannot continue.



For this purpose, there is a built-in function ```panic```
that in effect creates a run-time error that will stop the program
(but see the next section).  The function takes a single argument
of arbitrary type often a string to be printed as the
program dies.  It's also a way to indicate that something impossible has
happened, such as exiting an infinite loop.



```golang
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```


This is only an example but real library functions should
avoid ```panic```.  If the problem can be masked or worked
around, it's always better to let things continue to run rather
than taking down the whole program.  One possible counterexample
is during initialization: if the library truly cannot set itself up,
it might be reasonable to panic, so to speak.


```golang
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

### "recover">Recover


When ```panic``` is called, including implicitly for run-time
errors such as indexing a slice out of bounds or failing a type
assertion, it immediately stops execution of the current function
and begins unwinding the stack of the goroutine, running any deferred
functions along the way.  If that unwinding reaches the top of the
goroutine's stack, the program dies.  However, it is possible to
use the built-in function ```recover``` to regain control
of the goroutine and resume normal execution.



A call to ```recover``` stops the unwinding and returns the
argument passed to ```panic```.  Because the only code that
runs while unwinding is inside deferred functions, ```recover```
is only useful inside deferred functions.



One application of ```recover``` is to shut down a failing goroutine
inside a server without killing the other executing goroutines.


```golang
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```


In this example, if ```do(work)``` panics, the result will be
logged and the goroutine will exit cleanly without disturbing the
others.  There's no need to do anything else in the deferred closure;
calling ```recover``` handles the condition completely.



Because ```recover``` always returns ```nil``` unless called directly
from a deferred function, deferred code can call library routines that themselves
use ```panic``` and ```recover``` without failing.  As an example,
the deferred function in ```safelyDo``` might call a logging function before
calling ```recover```, and that logging code would run unaffected
by the panicking state.



With our recovery pattern in place, the ```do```
function (and anything it calls) can get out of any bad situation
cleanly by calling ```panic```.  We can use that idea to
simplify error handling in complex software.  Let's look at an
idealized version of a ```regexp``` package, which reports
parsing errors by calling ```panic``` with a local
error type.  Here's the definition of ```Error```,
an ```error``` method, and the ```Compile``` function.


```golang
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```


If ```doParse``` panics, the recovery block will set the
return value to ```nil``` deferred functions can modify
named return values.  It will then check, in the assignment
to ```err```, that the problem was a parse error by asserting
that it has the local type ```Error```.
If it does not, the type assertion will fail, causing a run-time error
that continues the stack unwinding as though nothing had interrupted
it.
This check means that if something unexpected happens, such
as an index out of bounds, the code will fail even though we
are using ```panic``` and ```recover``` to handle
parse errors.



With error handling in place, the ```error``` method (because it's a
method bound to a type, it's fine, even natural, for it to have the same name
as the builtin ```error``` type)
makes it easy to report parse errors without worrying about unwinding
the parse stack by hand:


```golang
if pos == 0 {
    re.error("'*' illegal at start of expression")
}
```


Useful though this pattern is, it should be used only within a package. ```Parse``` turns its internal ```panic``` calls into ```error``` values; it does not expose ```panics```
to its client.  That is a good rule to follow.



By the way, this re-panic idiom changes the panic value if an actual
error occurs.  However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible.  Thus this simple re-panic approach is usually
sufficient it's a crash after all but if you want to
display only the original value, you can write a little more code to
filter unexpected problems and re-panic with the original error.
That's left as an exercise for the reader.



## "web_server">A web server


Let's finish with a complete Go program, a web server.
This one is actually a kind of web re-server.
Google provides a service at
<a href="http://chart.apis.google.com">http://chart.apis.google.com</a>
that does automatic formatting of data into charts and graphs.
It's hard to use interactively, though,
because you need to put the data into the URL as a query.
The program here provides a nicer interface to one form of data: given a short piece of text,
it calls on the chart server to produce a QR code, a matrix of boxes that encode the
text.
That image can be grabbed with your cell phone's camera and interpreted as,
for instance, a URL, saving you typing the URL into the phone's tiny keyboard.


Here's the complete program.
An explanation follows.

```golang
//{{code "/doc/progs/eff_qr.go" `/package/` `$`}}
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"html/template"
	"log"
	"net/http"
)

var addr = flag.String("addr", ":1718", "http service address") // Q=17, R=18

var templ = template.Must(template.New("qr").Parse(templateStr))

func main() {
	flag.Parse()
	http.Handle("/", http.HandlerFunc(QR))
	err := http.ListenAndServe(*addr, nil)
	if err != nil {
		log.Fatal("ListenAndServe:", err)
	}
}

func QR(w http.ResponseWriter, req *http.Request) {
	templ.Execute(w, req.FormValue("s"))
}

const templateStr = `
<html>
<head>
<title>QR Link Generator</title>
</head>
<body>
{{if .}}
<img src="http://chart.apis.google.com/chart?chs=300x300&cht=qr&choe=UTF-8&chl={{.}}" />
<br>
{{.}}
<br>
<br>
{{end}}
<form action="/" name=f method="GET"><input maxLength=1024 size=70
name=s value="" title="Text to QR Encode"><input type=submit
value="Show QR" name=qr>
</form>
</body>
</html>
```

The pieces up to ```main``` should be easy to follow.
The one flag sets a default HTTP port for our server.  The template
variable ```templ``` is where the fun happens. It builds an HTML template
that will be executed by the server to display the page; more about
that in a moment.


The ```main``` function parses the flags and, using the mechanism
we talked about above, binds the function ```QR``` to the root path
for the server.  Then ```http.ListenAndServe``` is called to start the
server; it blocks while the server runs.


_ ```QR``` just receives the request, which contains form data, and
executes the template on the data in the form value named ```s```.


The template package ```html/template``` is powerful;
this program just touches on its capabilities.
In essence, it rewrites a piece of HTML text on the fly by substituting elements derived
from data items passed to ```templ.Execute```, in this case the
form value.
Within the template text (```templateStr```),
double-brace-delimited pieces denote template actions.
The piece from ```{{html "{{if .}}"}}```
to ```{{html "{{end}}"}}``` executes only if the value of the current data item, called ```.``` (dot),
is non-empty.
That is, when the string is empty, this piece of the template is suppressed.


The two snippets ```{{html "{{.}}"}}``` say to show the data presented to
the template—the query string—on the web page.
The HTML template package automatically provides appropriate escaping so the
text is safe to display.


The rest of the template string is just the HTML to show when the page loads.
If this is too quick an explanation, see the <a href="/pkg/html/template/">documentation</a>
for the template package for a more thorough discussion.


And there you have it: a useful web server in a few lines of code plus some
data-driven HTML text.
Go is powerful enough to make a lot happen in a few lines.
